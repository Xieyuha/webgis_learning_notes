# 模块化
解决聚合、依赖混乱问题
## ES6 模块化学习笔记（含导出示例）
编译时静态模块系统（ESM，ECMAScript Modules）
- 核心概念
    - 一个文件就是一个模块，默认严格模式
    - 语法静态、可被编译器/打包器静态分析
    - 导出的是活绑定（live binding），单例
    - 支持按需加载、代码分割

- 具名导出与导入
    ```js
    // math.js
    export const PI = 3.14159;
    export function area(r) { return PI * r * r; }
    export class Circle {
        constructor(r) { this.r = r; }
        area() { return area(this.r); }
    }

    // main.js
    import { PI, area, Circle } from './math.js';
    console.log(PI, area(2), new Circle(3).area());
    ```

- 默认导出与导入
    ```js
    // api.js
    export default async function request(url, opts = {}) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
    }

    // main.js
    import request from './api.js';
    request('/users').then(console.log);
    ```

- 同时使用默认导出与具名导出
    ```js
    // config.js
    export const BASE_URL = '/api';
    export const TIMEOUT = 8000;
    const config = { env: 'dev' };
    export default config;

    // main.js
    import cfg, { BASE_URL, TIMEOUT } from './config.js';
    console.log(cfg.env, BASE_URL, TIMEOUT);
    ```

- 重命名与命名空间导入
    ```js
    // alias
    import { area as circleArea } from './math.js';
    console.log(circleArea(5));

    // namespace
    import * as math from './math.js';
    console.log(math.PI, math.area(4), new math.Circle(6).area());
    ```

- 再导出（聚合导出）
    ```js
    // utils/index.js
    export { area, Circle } from '../math.js'; // 选择性再导出
    export * from '../string.js';              // 批量再导出

    // main.js
    import { area, capitalize } from './utils/index.js';
    ```

- 动态导入（代码分割）
    ```js
    // main.js
    async function run() {
        const { area } = await import('./math.js');
        console.log(area(10));
    }
    run();

    // 顶层 await（ES2022+，仅在 ESM 中可用）
    const mod = await import('./math.js');
    console.log(mod.PI);
    ```

- 浏览器中使用
    ```html
    <!-- index.html -->
    <script type="module" src="./main.js"></script>
    ```

- Node.js 中使用
    - package.json 中设置: { "type": "module" }，或使用 .mjs 扩展名
    - 使用 import 路径需写扩展名，或由打包器处理

- 与 CommonJS 的区别
    - ESM 是静态的、编译时绑定；CJS 是运行时加载
    - import 提升且只读活绑定；require 则返回值拷贝（引用）但非活绑定
    - this 在模块顶层为 undefined；CJS 中为 module.exports
    - 循环依赖：ESM 按声明顺序创建绑定，可能拿到未初始化的占位符，注意导入时机

- 注意事项
    - import/export 只能在模块顶层使用
    - 浏览器原生加载需使用相对或绝对 URL，并保留文件扩展名
    - 每个模块最多一个 default 导出，具名导出可有多个
    - 避免在默认导出与具名导出之间产生语义混淆，团队约定更重要