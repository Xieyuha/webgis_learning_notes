#前端网络
##分层模型与协议应用
###分层模型
####五层网络模型
物理层->数据链路层->网络层->传输层->应用层
####数据的传输
###应用层协议
####URL
统一资源定位符：定位网络服务
固定的字符串
![alt text](./img/image.png)
schema  domain  port    path    query   hash
 协议    域名    端口    服务     细节
path会补全/
query可以省略
live server静态资源服务器
####HTTP
超文本传输协议
    消息传输的模式
        请求<->响应
        客户端发出请求，服务器响应请求
响应码 
    1
    2
    3   服务器程序  301永久重定向   302临时重定向
    4
    5
    消息传输模式
        字符串
##浏览器的通信能力
###用户代理
浏览器中$0.href,$0.Attribute
书写地址(绝对路径，相对路径(前端中相对url))
    -转换->url
    绝对路径
        //www.baidu.com/a.html
            省略协议名是为了避免由开发环境转向生产环境时变更协议名从http到https
        /a.html
            使用当前页面的域名，与当前页面路径无关
    相对路径
        ./2.html
            http://www.baidu.com/a/2.html
            相对于路径
            ./可以省略
        ../3.html
        www.baidu.com/3.html
form表单
```javascript
    <form action="https://baidu.com" method="post">
        <input type="text" name="logId" value="">
        <button type="submit"></button>
    </form>
```
    action存放url ，method请求方式
    name是请求体中的键
    value是请求体中的值
    button submit是当前表单发送一次请求
目前更多js发送请求，但同时监听点击、回车、tab等事件，仍用form表单方便
表单内阻止默认行为后可以接ajax发送请求
    form.onsubmit = function(e)
    e.preventDefault()
content-type
    请求体的数据格式(POST)、响应体的数据格式
GET与POST区别
    协议层面
    语义差别，表示不同的目的
    1.发送GET请求时，不会附带请求体
    2.GET请求的传递信息量有限，适合传递少量数据，且只能是ASCII字符，非ASCII字符需要编码
    3.大部分GET请求传递的数据都附在path参数中，能通过分享地址完整的重现页面，但同时也暴露数据，敏感数据不适合用GET请求传递，至少不在path参数中传递
    4.POST不会放在历史记录中/缓存中/刷新：复现请求，POST页面刷新会重新发送请求

####基本流程
    输入url回车后会发生哪些事情
###AJAX
AJAX(原生能力):发请求、拿响应(处理是js负责处理)
    xhr对象
    fetch
####fetch案例
```javascript
    async function fetchDemo(){
        //async是定义异步函数，await是等待异步操作完成后再继续执行后续代码
        const resp = await fetch('https://api.github.com/users/github');
        //发请求，得到响应头，这样响应头、体分开处理是为了避免响应体大文件阻塞
        const data = await response.json();
        //解析响应体，.json()返回一个promise对象，在在异步操作得到响应体后再转为json对象，.text()、.blob()类似
        console.log(data);
    }
```
    async await原理
        基于promise实现异步操作的同步化写法
        async函数执行后返回一个promise对象
```javascript
    function fetchDemo(){
        return fetch('https://api.github.com/users/github')
            .then(response => response.json())
            .then(data => {
                console.log(data);
            });
    }
```
fetch不能做监控请求进度，例如文件上传
axios(第三方库)
    基于promise的xhr封装
        promise是代码风格/组装形式
umi-request(第三方库)
    基于fetch的封装
####文件上传案例
    I/O操作一定是异步，否则阻塞主线程
    交互逻辑    JS
        input type="file" multipe 选择多个文件
    选择图片->显示预览图片->显示上传进度->上传完成
    请求逻辑    AJAX
```javascript
    const xhr = new XMLHttpRequest()
    const url = '#'
    xhr.open('POST', url, true)//true异步
    xhr.onload = ()=>{
        if(xhr.status === 200){
            console.log('上传成功')
        }else{
            console.log('上传失败')
        }
    }
    xhr.upload.onprogress = (e)=>{
        const percent = Math.floor((e.loaded / e.total) * 100)
        console.log(`上传进度：${percent}%`)
    }
    //xhr.abort() //取消上传
    const formData = new FormData() //FormData对象用于构建表单数据,这里是提交请求体
    formData.append('avatar',file)  //append(key,value) content-disposition的内容
    xhr.send(formData)
```
##跨域问题及解决方案
###同源策略及跨域问题
同源策略是一套浏览器安全机制，当一个源的文档和脚本，与另一个源的资源进行通信时，同源策略就会对这个通信做不不同程度的限制。
    同源策略对同源资源放行，对异源资源限制
####同源和异源
    源(origin) = 协议 + 域名 + 端口号
    只要有一个不同就是异源
####跨域出现场景
    .网络通信
    .js API
    .存储
####网络中的跨域
    请求页面的源称为页面源，在该页面发出的请求称为目标源。--->页面源与目标源不同即跨域请求
####浏览器如何限制异源请求
    对标签发出的跨域请求轻微限制
        img、script、link标签发出的跨域请求不受同源策略限制，可以正常加载资源
        iframe、audio、video标签发出的跨域请求受限，无法获取响应体内容
    对AJAX发出的跨域请求严格限制
        AJAX发出的跨域请求会被浏览器拦截，无法获取响应体内容
###跨域解决方案
具体情况具体分析
####CORS
响应结果的校验规则
基本理念
    只要服务器明确表示允许，则校验通过
    服务器明确拒绝或没有表示，则校验不通过
所以，使用CORS解决跨域，必须保证服务器是“自己人”(同一公司或有合作关系)
#####请求分类
简单请求(simple request)、预检请求(preflight request)
######简单请求
    请求方法是GET、POST、HEAD之一
    头部字段满足CORS安全规范
        浏览器默认自带头部都是安全的
    Content-Type是以下三种之一
        text/plain
        multipart/form-data
        application/x-www-form-urlencoded
文件上传是什么请求？
    根据content-type判断，看情况
    multipart/form-data--->简单请求
    application/json--->base64 预检请求
    转成二进制放到请求体中--->预检请求
#####对简单请求的验证
    请求头部
        Origin: 发起请求的页面源
    响应头部
        Access-Control-Allow-Origin: 允许访问的源，可以是具体源，也可以是*，建议不要用*，可能存在隐患
#####对预检请求的验证
    1.发送预检请求
        OPTIONS方法发出
            请求与响应字段必须匹配，否则浏览器拦截
        带有特殊头部字段的请求
            Origin: 发起请求的页面源
            Access-Control-Request-Method: 实际请求的方法
            Access-Control-Request-Headers: 实际请求的头部字段
        响应头部
            Access-Control-Allow-Origin: 允许访问的源
            Access-Control-Allow-Methods: 允许的方法
            Access-Control-Allow-Headers: 允许的头部字段
            Access-Control-Max-Age: 预检请求结果的缓存时间，单位秒  //多长时间内不要再发options请求
    2.发送真实请求(与简单请求相同)
#####细节1-关于cookie
    1.同源请求携带cookie，跨域请求默认不携带cookie
    2.如果需要跨域请求携带cookie，必须设置withCredentials
        xhr.withCredentials = true
        fetch时设置credentials: 'include'
    3.服务器需要在响应头中设置Access-Control-Allow-Credentials: true
#####细节2-关于跨域获取响应头
    默认情况下，AJAX只能获取部分响应头
    如果需要获取其他响应头，服务器需要在响应头中设置Access-Control-Expose-Headers，值为允许获取的响应头名称列表
####JSONP
JSONP (JSON with Padding) 是一种非官方的跨域数据获取技术，利用<script>标签不受同源策略限制的特点，通过动态创建<script>标签来实现跨域请求数据。
基本原理
    1.客户端定义一个回调函数，用于处理服务器返回的数据
    2.客户端动态创建一个<script>标签，src属性指向服务器的URL，并在URL中传递回调函数的名称作为参数
    3.服务器接收到请求后，生成一段JavaScript代码，这段代码会调用客户端传递的回调函数，并将数据作为参数传递给该函数
    4.浏览器加载并执行这段JavaScript代码，从而实现跨域数据获取
使用
    接收函数名要与服务器返回的函数名一致
    接收函数名可以动态生成，避免冲突，但要将动态参数传给服务器，使服务器同步生成对应的函数名
缺陷
    1.仅支持GET请求，无法使用POST等其他HTTP方法
    2.安全性较低，容易受到XSS攻击
        利用callback=恶意函数的方式进行攻击
    3.依赖服务器端的支持，服务器必须按照JSONP的格式返回数据
####代理服务器
    CORS和JSONP都需要服务器配合，而代理可以在不修改服务器的情况下实现跨域请求
基本原理
    1.客户端向同源的代理服务器发送请求，请求中包含目标资源的URL
    2.代理服务器接收到请求后，向目标资源的服务器发送请求
    //原因:只有浏览器存在跨域问题，服务器之间不存在跨域问题
    3.目标资源的服务器响应请求，返回数据给代理服务器
    4.代理服务器将数据返回给客户端
####如何选择
    生产环境和开发环境一致