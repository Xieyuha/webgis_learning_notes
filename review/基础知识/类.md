# js类
javascript类是基于构造函数和原型继承的一种语法糖，底层逻辑仍然是基于原型的继承机制
- class 本质是函数：typeof MyClass === "function"
- class 方法是加在 prototype 上的，而不是加在实例上
## 为什么使用类
- 视情况而定，基于面向对象编程（OOP）的设计模式在某些场景下更适合解决问题
- 与之相反是面向过程，使用函数和数据结构来组织代码(数据可变性更强、、内部状态更容易被外部修改)
- JS 支持多范式（OOP + 函数式 + 原型式），class 是 JS 设计为了兼容 Java/C# 开发者的一层抽象
## 三大特性
### 封装
- 不应该访问对象的底层实现，而是使用抽象方法来与之交互
### 继承
- 子类可以通过 `extends` 关键字继承父类
- 子类会自动获得父类的所有属性和方法
- 可以重写父类的方法
### 多态
- 子类可以重写父类的方法，以实现不同的行为
- 通过父类引用调用子类的方法时，会执行子类的实现
- JS 的多态不依赖类型检查，而是依赖对象是否“具有某个方法”（鸭子类型）
    - 即使两个类没有继承关系，只要它们实现了相同的方法，就可以互换使用

## 使用
### class fields
(es2022+)
- 解决两个问题
    1. 实例属性必须写到 constructor 里，写起来冗长难看
    2. 初始化表达式不方便写（比如回调、函数、箭头函数）
- 在类中直接定义属性，而不是在构造函数中定义
- class fields（不加 static）= 实例属性，等价于 constructor 里写 this.x = …
### constructor关键字
- 在一个类中只能有一个；
- 在 new 的时候会自动执行；
- 负责造出实例

### 构造函数
- class 具有内部方法 `[[Construct]]`（构造方法）
- class 原型链仍然通过 `prototype` 和 `__proto__` 建立
- 但 class 本身不能当普通函数调用（必须 new）
```js
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```
### 私有字段
硬私有：如果类没有实现暴露这些私有字段的方法，也就没有任何机制可以从类外访问它们
私有字段不能通过 `this['#name']` 访问，不能通过反射访问，不能动态生成变量名访问，是无法绕开的硬私有。
- 使用 `#` 前缀来定义私有字段和方法
- 私有字段只能在类的内部访问，外部无法访问

### 静态属性
- 使用 `static` 关键字来定义静态属性和方法
- 静态属性和方法属于类本身，而不是类的实例
- 静态方法里 this 指向类本身，而非实例
## 注意
- 类声明不会提升到作用域顶部
- 类会进入暂时性死区（TDZ）
- 类必须在定义之后才能使用（与 let/const 一致）
## 一个完整案例
```js
class Animal {
    static kingdom = 'Animalia'; // 静态属性

    #privateField = 'I am private'; // 私有字段
    constructor(name) {
        this.name = name; // 公共属性
    }
    speak() { // 公共方法
        console.log(`${this.name} makes a noise.`);
    }
    #privateMethod() { // 私有方法
        console.log(this.#privateField);
    }
    revealPrivate() { // 通过公共方法访问私有方法
        this.#privateMethod();
    }
}
class Dog extends Animal {
    /* 必须先调用 super() 才能使用 this，否则会抛出 ReferenceError */
    //调用父类的 constructor
    //建立正确的 this（否则无法访问 this）
    constructor(name, breed) {
        super(name);
        this.breed = breed; // 公共属性
    }
    speak() { // 重写公共方法
        console.log(`${this.name} barks.`);
    }
}
const dog = new Dog('Rex', 'German Shepherd');
dog.speak(); // Rex barks.      
```